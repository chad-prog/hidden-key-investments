name: Smoke Test - Production

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read
  statuses: write
  # NOTE: We need write permission for issues to comment the patch URL
  # and write for artifacts to upload the patch artifact.
  issues: write 
  actions: read # Needed for upload-artifact to reference run info

jobs:
  smoke-prod:
    name: Run Smoke Tests on Production
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js 22
        uses: actions/setup-node@v4
        with:
          node-version: '22'
      
      - name: Run smoke test
        id: smoke
        continue-on-error: true
        env:
          SMOKE_BASE: ${{ secrets.SMOKE_BASE_PROD }}
          SMOKE_ORIGIN: ${{ secrets.SMOKE_ORIGIN_PROD }}
          MAUTIC_CAMPAIGN_INVESTOR_WELCOME: ${{ secrets.MAUTIC_CAMPAIGN_INVESTOR_WELCOME_PROD }}
          MAUTIC_BASE_URL: ${{ secrets.MAUTIC_BASE_URL }}
          MAUTIC_CLIENT_ID: ${{ secrets.MAUTIC_CLIENT_ID }}
          MAUTIC_CLIENT_SECRET: ${{ secrets.MAUTIC_CLIENT_SECRET }}
          MAUTIC_WEBHOOK_SECRET: ${{ secrets.MAUTIC_WEBHOOK_SECRET }}
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        run: |
          node scripts/smoke-run.mjs
      
      - name: Set commit status
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const state = '${{ steps.smoke.outcome }}' === 'success' ? 'success' : 'failure';
            const description = state === 'success' 
              ? 'Production smoke tests passed' 
              : 'Production smoke tests failed';
            
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.sha,
              state: state,
              target_url: `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
              description: description,
              context: 'smoke/prod'
            });
      
      - name: Upload smoke log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: smoke-prod-log
          path: smoke.log
          if-no-files-found: warn

# INSERT PATCH ATTACHMENT HERE ‚¨áÔ∏è
      - name: Generate and Attach CRP Patch
        if: github.event_name == 'pull_request'
        run: |
          echo "Preparing patch bundle..."
          # Assume patch has been generated by prior steps or dedicated script
          # The patch file must exist in the root directory for this to work
          if [ -f guardrails-crp-anchor-and-index.patch ]; then
            echo "Patch found."
          else
            echo "Patch not found; creating placeholder patch."
            # Create a placeholder patch if it doesn't exist (e.g., if CI didn't generate it)
            cat > guardrails-crp-anchor-and-index.patch <<'PATCH'
--- /dev/null
+++ b/docs/chats/CONVERSATION-ANCHOR.md
@@ 0,0 +1,1 @@
+# Placeholder anchor (to be replaced by actual patch in CI)
PATCH
          fi

          echo "Uploading patch as artifact..."
          mkdir -p artifacts
          cp guardrails-crp-anchor-and-index.patch artifacts/
          
      - name: Upload CRP Patch Artifact
        if: github.event_name == 'pull_request'
        uses: actions/upload-artifact@v4
        with:
          name: guardrails-crp-anchor-and-index.patch
          path: artifacts/guardrails-crp-anchor-and-index.patch

      - name: Comment with Patch URL
        if: github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork == false
        uses: actions/github-script@v7
        with:
          script: |
            const runUrl = `${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`;
            const prNumber = ${{ github.event.pull_request.number }};
            await github.rest.issues.createComment({
              issue_number: prNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `CRP patch bundle attached to this PR (Artifacts tab): ${runUrl}`
            });
# END PATCH ATTACHMENT ‚¨ÜÔ∏è
      
      - name: Check rollback prerequisites
        id: rollback_check
        if: steps.smoke.outcome != 'success'
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID_PROD }}
        run: |
          if [ -n "$NETLIFY_AUTH_TOKEN" ] && [ -n "$NETLIFY_SITE_ID" ]; then
            echo "rollback_enabled=true" >> $GITHUB_OUTPUT
            echo "Rollback enabled: Tokens found."
          else
            echo "rollback_enabled=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Auto-rollback disabled: NETLIFY_AUTH_TOKEN or NETLIFY_SITE_ID_PROD not configured"
          fi
          
      - name: Auto-rollback on failure
        if: steps.rollback_check.outputs.rollback_enabled == 'true'
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID_PROD }}
        run: |
          echo "üö® Smoke test failed! Attempting auto-rollback..."
          
          # Fetch list of recent deploys
          DEPLOYS=$(curl -s -X GET \
            "https://api.netlify.com/api/v1/sites/${NETLIFY_SITE_ID}/deploys?per_page=10" \
            -H "Authorization: Bearer ${NETLIFY_AUTH_TOKEN}")
          
          # Find the currently published deploy
          CURRENT_DEPLOY=$(echo "$DEPLOYS" | jq -r '.[] | select(.published_at != null) | .id' | head -n 1)
          
          # Find the previous ready deploy (not the current published one)
          PREVIOUS_DEPLOY=$(echo "$DEPLOYS" | jq -r ".[] | select(.state == \"ready\" and .id != \"$CURRENT_DEPLOY\") | .id" | head -n 1)
          
          if [ -z "$PREVIOUS_DEPLOY" ]; then
            echo "‚ùå No previous ready deploy found. Cannot rollback."
            exit 1
          fi
          
          echo "üì¶ Current deploy: $CURRENT_DEPLOY"
          echo "‚è™ Rolling back to: $PREVIOUS_DEPLOY"
          
          # Restore the previous deploy
          RESTORE_RESPONSE=$(curl -s -X POST \
            "https://api.netlify.com/api/v1/sites/${NETLIFY_SITE_ID}/deploys/${PREVIOUS_DEPLOY}/restore" \
            -H "Authorization: Bearer ${NETLIFY_AUTH_TOKEN}")
          
          echo "‚úÖ Rollback initiated"
          echo "$RESTORE_RESPONSE" | jq '.'
          
          # Update commit status to indicate rollback
          echo "ROLLBACK_DEPLOY_ID=${PREVIOUS_DEPLOY}" >> $GITHUB_ENV
      
      - name: Update commit status with rollback info
        if: env.ROLLBACK_DEPLOY_ID != ''
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.sha,
              state: 'failure',
              target_url: `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
              description: `Smoke failed, rolled back to ${process.env.ROLLBACK_DEPLOY_ID}`,
              context: 'smoke/prod'
            });
      
      - name: Fail if smoke test failed
        if: steps.smoke.outcome != 'success'
        run: |
          echo "‚ùå Production smoke tests failed"
          exit 1