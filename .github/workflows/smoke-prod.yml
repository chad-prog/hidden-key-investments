name: Smoke Test - Production

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      smoke_base:
        description: 'Base URL to test (overrides secret)'
        required: false
        type: string
      smoke_origin:
        description: 'Origin for CORS (overrides secret)'
        required: false
        type: string
      campaign_id:
        description: 'Mautic campaign ID (overrides secret)'
        required: false
        type: string

jobs:
  smoke-test-production:
    name: Run Smoke Tests on Production
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js 22
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run smoke tests
        id: smoke
        env:
          SMOKE_BASE: ${{ inputs.smoke_base || secrets.SMOKE_BASE_PROD }}
          SMOKE_ORIGIN: ${{ inputs.smoke_origin || secrets.SMOKE_ORIGIN_PROD }}
          MAUTIC_CAMPAIGN_INVESTOR_WELCOME: ${{ inputs.campaign_id || secrets.MAUTIC_CAMPAIGN_INVESTOR_WELCOME_PROD }}
        run: |
          echo "Running smoke tests against production..."
          if node scripts/smoke-run.mjs; then
            echo "SMOKE_STATUS=success" >> $GITHUB_ENV
          else
            echo "SMOKE_STATUS=failure" >> $GITHUB_ENV
            exit 1
          fi
        continue-on-error: true

      - name: Set commit status
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const state = process.env.SMOKE_STATUS === 'success' ? 'success' : 'failure';
            const description = process.env.SMOKE_STATUS === 'success' 
              ? 'Production smoke tests passed' 
              : 'Production smoke tests failed';
            
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.sha,
              state: state,
              target_url: `${context.payload.repository.html_url}/actions/runs/${context.runId}`,
              description: description,
              context: 'smoke/prod'
            });

      - name: Upload smoke test log
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: smoke-prod-log
          path: smoke.log
          retention-days: 90

      - name: Write job summary
        if: always()
        run: |
          echo "## Production Smoke Test Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "$SMOKE_STATUS" = "success" ]; then
            echo "‚úÖ **Status:** PASSED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All required production smoke tests passed successfully!" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Status:** FAILED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Some production smoke tests did not pass. Automatic rollback will be attempted if configured." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Base URL:** \`$SMOKE_BASE\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Origin:** \`$SMOKE_ORIGIN\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Campaign ID:** \`${MAUTIC_CAMPAIGN_INVESTOR_WELCOME:-not set}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "View the uploaded \`smoke-prod-log\` artifact for complete test output." >> $GITHUB_STEP_SUMMARY

      - name: Attempt automatic rollback on failure
        if: env.SMOKE_STATUS == 'failure' && secrets.NETLIFY_AUTH_TOKEN != '' && secrets.NETLIFY_SITE_ID_PROD != ''
        uses: actions/github-script@v7
        with:
          script: |
            const https = require('https');
            
            console.log('üîÑ Attempting automatic rollback...');
            
            const siteId = process.env.NETLIFY_SITE_ID_PROD;
            const authToken = process.env.NETLIFY_AUTH_TOKEN;
            
            // Function to make Netlify API request
            function netlifyRequest(method, path, data = null) {
              return new Promise((resolve, reject) => {
                const options = {
                  hostname: 'api.netlify.com',
                  path: path,
                  method: method,
                  headers: {
                    'Authorization': `Bearer ${authToken}`,
                    'Content-Type': 'application/json'
                  }
                };
                
                const req = https.request(options, (res) => {
                  let body = '';
                  res.on('data', (chunk) => body += chunk);
                  res.on('end', () => {
                    if (res.statusCode >= 200 && res.statusCode < 300) {
                      resolve(JSON.parse(body));
                    } else {
                      reject(new Error(`HTTP ${res.statusCode}: ${body}`));
                    }
                  });
                });
                
                req.on('error', reject);
                if (data) req.write(JSON.stringify(data));
                req.end();
              });
            }
            
            try {
              // Get list of deployments
              console.log('Fetching recent deployments...');
              const deployments = await netlifyRequest('GET', `/api/v1/sites/${siteId}/deploys?per_page=10`);
              
              // Find previous ready deployment (skip the current failed one)
              const currentDeploy = deployments[0];
              const previousDeploy = deployments.find((d, idx) => 
                idx > 0 && d.state === 'ready' && d.published_at
              );
              
              if (!previousDeploy) {
                console.log('‚ùå No previous ready deployment found for rollback');
                core.setFailed('No previous deployment available for rollback');
                return;
              }
              
              console.log(`Found previous deployment: ${previousDeploy.id}`);
              console.log(`  Created: ${previousDeploy.created_at}`);
              console.log(`  Branch: ${previousDeploy.branch}`);
              console.log(`  Context: ${previousDeploy.context}`);
              
              // Restore the previous deployment
              console.log('Restoring previous deployment...');
              await netlifyRequest('POST', `/api/v1/sites/${siteId}/deploys/${previousDeploy.id}/restore`);
              
              console.log('‚úÖ Successfully rolled back to previous deployment');
              console.log(`Rollback URL: https://app.netlify.com/sites/${siteId}/deploys/${previousDeploy.id}`);
              
              // Add to job summary
              core.summary
                .addHeading('üîÑ Automatic Rollback Completed', 2)
                .addRaw(`Successfully rolled back to deployment \`${previousDeploy.id}\``)
                .addBreak()
                .addRaw(`Created: ${previousDeploy.created_at}`)
                .addBreak()
                .addRaw(`Branch: ${previousDeploy.branch}`)
                .write();
              
            } catch (error) {
              console.error('‚ùå Rollback failed:', error.message);
              core.setFailed(`Automatic rollback failed: ${error.message}`);
            }
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID_PROD: ${{ secrets.NETLIFY_SITE_ID_PROD }}

      - name: Fail workflow if smoke tests failed
        if: env.SMOKE_STATUS == 'failure'
        run: |
          echo "::error::Production smoke tests failed"
          exit 1
